<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF Invoice/Statement Toolkit</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      background: #acdbf9;
      color: #333;
      padding: 2em;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    input[type="file"], button {
      margin: 1em 0;
      padding: 0.8em 1.5em;
      border-radius: 30px;
      border: 1px solid #000;
      font-size: 1em;
      background: #f8c9f9;
      transition: background-color 0.2s;
    }
    button:disabled { background: #f0d4f0; color: #999; border: 1px solid #999; cursor: not-allowed; }
    button:hover:not(:disabled), input[type="file"]:hover { background: #e8b3e8; }
    #output { white-space: pre-wrap; background: #fff; padding: 1em; border-radius: 6px; margin-top: 1em; width: 100%; min-height: 200px; box-sizing: border-box;}
    .back-home {
      display: inline-block;
      padding: 12px 24px;
      background-color: #f8c9f9;
      color: #333;
      text-decoration: none;
      font-size: 1rem;
      font-weight: bold;
      border-radius: 30px;
      text-align: center;
      border: 1px solid #000;
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 999;
      transition: background-color 0.2s ease;
    }
    .back-home:hover { background: #e8b3e8; }
    #notification {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #f8c9f9;
      color: #333;
      padding: 10px 20px;
      border-radius: 5px;
      display: none;
      z-index: 1000;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <a href="index.html" class="back-home">Back to Home</a>
  <h1>PDF Invoice/Statement Toolkit</h1>
  <input type="file" id="fileInput" accept="application/pdf" />
  <button id="exportExcelBtn" disabled>Export to Excel</button>
  <div id="notification"></div>
  <div id="output"></div>

  <script>
     const HEADERS = [
      "Claim Number",
      "Service Date(s)",
      "Procedure",
      "Units",
      "Unit Rate",
      "Total Charge",
      "Patient Charge",
      "Total Paid",
      "Ins. Paid",
      "Patient Paid",
      "Total Adj.",
      "Total Balance",
      "Ins. Balance",
      "Patient Balance"
    ];

    let sheets = []; // Array of arrays of parsed rows, per statement
    let previewHTML = ""; // HTML preview for output div

    // Utility: Clean unwanted lines from text
    function cleanLine(line) {
      let cleaned = line
        .replace(/State\s+of\s+South\s+Dakota\s+Department\s+of\s+Health/gi, "")
        .replace(/600\s+E\s+Capitol\s+Ave/gi, "")
        .replace(/Pierre,\s+SD\s+57501/gi, "")
        .trim();
      // Remove lines that are now empty after cleaning
      if (
        !cleaned ||
        /State\s+of\s+South\s+Dakota\s+Department\s+of\s+Health/i.test(line) ||
        /Disclaimer: Charges\/Adjustments made after statement date will appear on your next statement. Questions: Please call \(605\)773-6031/i.test(line) ||
        /600\s+E\s+Capitol\s+Ave/i.test(line) ||
        /Pierre,\s+SD\s+57501/i.test(line)
      ) return "";
      return cleaned;
    }
function showNotification(msg) {
      const n = document.getElementById("notification");
      n.textContent = msg;
      n.style.display = "block";
      setTimeout(() => { n.style.display = "none"; }, 3000);
    }

    // Parse one statement's chunk into table rows
    function parseStatementRows(lines) {
      // Find the header line by matching all header names
      const headerIdx = lines.findIndex(line =>
        HEADERS.every(h =>
          line.toLowerCase().includes(h.toLowerCase().split(" ")[0]) // match by first word
        )
      );
      // If header not found, guess it's the first row
      let dataLines = headerIdx !== -1 ? lines.slice(headerIdx + 1) : lines;
      // Remove summary/blank lines
      dataLines = dataLines.filter(l => l.trim() && !l.toLowerCase().includes("disclaimer"));

      // Parse each data line into columns
      const tableRows = [];
      dataLines.forEach(line => {
        // Attempt to split by whitespace, but preserve procedure (may contain spaces)
        // Assume: Claim Number (no spaces), then Service Date(s) (date format), then Procedure (may have spaces), then numbers
        const tokens = line.trim().split(/\s+/);
        if (tokens.length < 8) return; // skip short lines

        // Find the index of the service date (MM/DD/YYYY or MM/DD/YY)
        let dateIdx = tokens.findIndex(tok => /^\d{1,2}\/\d{1,2}\/\d{2,4}$/.test(tok));
        if (dateIdx === -1) return; // skip if no date

        // Assume claim number is before date, procedure is after date and before units (first number after date)
        const claimNumber = tokens.slice(0, dateIdx).join(' ');
        const serviceDate = tokens[dateIdx];
        // Find first number after date for units
        let unitsIdx = dateIdx + 1;
        while (unitsIdx < tokens.length && isNaN(tokens[unitsIdx].replace(/[^0-9.]/g, ''))) {
          unitsIdx++;
        }
        const procedure = tokens.slice(dateIdx + 1, unitsIdx).join(' ');
        const units = tokens[unitsIdx] || '';
        // The rest of the columns, map by order
        const rest = tokens.slice(unitsIdx + 1);

        // Map columns (fill blanks if missing)
        const row = [
          claimNumber,
          serviceDate,
          procedure,
          units,
          rest[0] || '', // Unit Rate
          rest[1] || '', // Total Charge
          rest[2] || '', // Patient Charge
          rest[3] || '', // Total Paid
          rest[4] || '', // Ins. Paid
          rest[5] || '', // Patient Paid
          rest[6] || '', // Total Adj.
          rest[7] || '', // Total Balance
          rest[8] || '', // Ins. Balance
          rest[9] || ''  // Patient Balance
        ];
        tableRows.push(row);
      });
      return tableRows;
    }

    // PDF file handler
    document.getElementById("fileInput").addEventListener("change", async function(event) {
      const file = event.target.files[0];
      if (!file) return;
      sheets = [];
      previewHTML = "";
      document.getElementById('output').textContent = "Extracting PDF...";
      document.getElementById('exportExcelBtn').disabled = true;

      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdfData = new Uint8Array(arrayBuffer);
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;

        // We treat each "statement date:" as a new sheet
        let currentLines = [];
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          let tempLines = textContent.items.map(item => item.str.trim()).filter(Boolean);

          // Clean all lines
          tempLines = tempLines.map(cleanLine).filter(Boolean);

          // Chunk out statements by "statement date:"
          while (tempLines.length > 0) {
            const statementIdx = tempLines.findIndex(
              line => line.toLowerCase().includes("statement date:")
            );
            if (statementIdx === -1) {
              // No statement marker, add all remaining lines to current sheet
              currentLines.push(...tempLines);
              tempLines = [];
            } else {
              // Found a statement date, start a new sheet
              // Drop everything before and including statement date
              tempLines = tempLines.slice(statementIdx + 1);
              if (currentLines.length > 0) {
                sheets.push([...currentLines]);
                currentLines = [];
              }
            }
          }
        }
        // Last sheet if it has content
        if (currentLines.length > 0) sheets.push([...currentLines]);

        // Now parse each sheet into table rows
        const parsedSheets = sheets.map(sheetLines => {
          const tableRows = parseStatementRows(sheetLines);
          return tableRows;
        });

        // Build preview HTML table
        if (parsedSheets.length === 0 || parsedSheets.every(s => s.length === 0)) {
          previewHTML = "No valid statement data found.";
          document.getElementById('exportExcelBtn').disabled = true;
        } else {
          previewHTML = parsedSheets.map((sheet, idx) => {
            if (!sheet.length) return `--- Statement ${idx + 1}: No rows found ---`;
            return `<b>Statement ${idx + 1}</b><table><tr>` +
              HEADERS.map(h => `<th>${h}</th>`).join('') +
              '</tr>' +
              sheet.map(row =>
                '<tr>' +
                row.map(cell => `<td>${cell}</td>`).join('') +
                '</tr>'
              ).join('') +
              '</table>';
          }).join('<br>');
          document.getElementById('exportExcelBtn').disabled = false;
          showNotification("PDF data extracted for " + parsedSheets.length + " statement(s)!");
        }
        document.getElementById('output').innerHTML = previewHTML;
        // Store parsed for export
        sheets = parsedSheets;

      } catch (e) {
        document.getElementById('output').textContent = "Error reading PDF!";
        showNotification("Error: Could not extract PDF data.");
      }
    });

    // Export to Excel handler
    document.getElementById('exportExcelBtn').onclick = function() {
      if (!sheets.length) return;
      const wb = XLSX.utils.book_new();
      sheets.forEach((tableRows, idx) => {
        // Add header row
        const wsData = [HEADERS, ...tableRows];
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        XLSX.utils.book_append_sheet(wb, ws, `Statement ${idx + 1}`);
      });
      XLSX.writeFile(wb, "Statements.xlsx");
    };
  </script>
</body>
</html>