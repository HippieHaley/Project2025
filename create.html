<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PDF → Excel/Word Statement Generator</title>

  <!-- libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx@7.5.0/build/index.js"></script>

  <style>
    :root{
      --blue:#acdbf9;
      --pink:#f8c9f9;
      --ink:#333;
      --radius:30px;
    }
    *{ box-sizing:border-box; }
    body{
      font-family:Arial, sans-serif;
      margin:0 auto;
      background:var(--blue);
      color:var(--ink);
      max-width:1100px;
      min-height:100vh;
      padding:80px 20px 40px;
      display:flex; flex-direction:column; gap:18px;
    }
    .back-home{
      position:fixed; top:20px; left:20px;
      background:var(--pink); color:#333; text-decoration:none;
      padding:12px 24px; border-radius:30px; border:1px solid #000; font-weight:700;
      transition:.2s background;
    }
    .back-home:hover{ background:#e8b3e8; }

    .controls{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
    }
    input[type="file"]{
      padding:10px 14px; border:1px solid #000; border-radius:30px; background:var(--pink); font-weight:700;
    }
    input[type="file"]::file-selector-button{
      padding:10px 20px; border:1px solid #000; border-radius:30px; background:var(--pink); font-weight:700; cursor:pointer;
      transition:.2s background;
    }
    input[type="file"]::file-selector-button:hover{ background:#e8b3e8; }

    button{
      padding:12px 24px; border:1px solid #000; border-radius:30px; background:var(--pink); font-weight:700; cursor:pointer;
      transition:.2s background;
    }
    button:hover{ background:#e8b3e8; }
    button:disabled{ background:#f0d4f0; color:#999; border-color:#999; cursor:not-allowed; }

    select{
      padding:10px 14px; border:1px solid #000; border-radius:12px; background:#fff; font-weight:600;
    }

    .banner{
      display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;
    }

    .pane{
      background:#fff; border:1.5px solid #000; border-radius:16px; padding:16px; box-shadow:0 6px 16px rgba(0,0,0,.08);
    }
    .client-info p{ margin:.2rem 0; }

    table{
      width:100%; border-collapse:collapse; background:#fff; margin-top:8px; border:2px solid #333; overflow:auto;
    }
    th, td{
      padding:10px 12px; border:1px solid #333; white-space:nowrap; text-align:left;
    }
    thead th{ background:var(--pink); color:#000; font-weight:700; }
    tbody tr:nth-child(odd){ background:#f7faff; }

    .totals{
      display:flex; justify-content:flex-end; gap:12px; align-items:center; margin-top:8px;
    }
    .pay-box{
      border:2px solid #000; border-radius:12px; padding:12px 16px; font-weight:800; background:#fff;
    }

    #notification{
      position:fixed; top:10px; right:10px; background:var(--pink); color:#333; padding:10px 20px;
      border-radius:8px; border:1px solid #000; display:none; z-index:999;
    }
  </style>
</head>
<body>
  <a class="back-home" href="index.html">Back to Home</a>

  <div id="notification"></div>

  <div class="banner">
    <h1 style="margin:0;">Invoice/Statement Generator</h1>
    <div class="controls">
      <input type="file" id="fileInput" accept="application/pdf"/>
      <select id="clientSelect" disabled></select>
      <button id="btnExportExcel" disabled>Export to Excel</button>
      <button id="btnDownloadWord" disabled>Download Word</button>
    </div>
  </div>

  <div class="pane client-info" id="clientInfo" style="display:none;">
    <h3 id="clientName"></h3>
    <div id="clientAddress"></div>
  </div>

  <div class="pane" id="tablePane" style="display:none;">
    <div class="totals">
      <div class="pay-box" id="payBox">PAY THIS AMOUNT: $0.00</div>
    </div>
    <table id="dataTable" aria-label="Statement preview">
      <thead>
        <tr>
          <th>Claim Number</th>
          <th>Service Date</th>
          <th>Procedure (and Codes)</th>
          <th>Units</th>
          <th>Unit Rate</th>
          <th>Total Charge</th>
          <th>Patient Charge</th>
          <th>Total Paid</th>
          <th>Insurance Paid</th>
          <th>Patient Paid</th>
          <th>Total Adjustment</th>
          <th>Total Balance</th>
          <th>Insurance Balance</th>
          <th>Balance Owed</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
/* =========================
   COMBINED SCRIPT (PDF → Excel/Preview/Word) + (Excel → Preview/Word)
   - Keeps your original functions & globals
   - Adds bridge helpers so both flows work in one page
   Requirements on the page:
     - pdf.js (pdfjsLib global)
     - SheetJS/xlsx (XLSX global)
     - docx (docx global)
   DOM ids used:
     fileInput (PDF), exportExcelBtn, notification, fileUpload (Excel, optional),
     clientName, clientAddress, dataTable (with <tbody>)
========================= */

/* ---------- GLOBAL STATE (union of both files) ---------- */
let sheets = [];                 // AoA data for each client (from PDF)
let clientInfo = [];             // [{ name, address }]
let sortedData = [];             // used by preview (rows for current client)
let clientName = "";             // used by preview
let balanceOwed = 0;             // running total for preview / Word
let formattedAddressLines = [];  // ["addr line 1", "city state zip"]
let allClients = [];             // canonical per-client objects for preview/Word

/* ---------- pdf.js worker ---------- */
if (window.pdfjsLib) {
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
}

/* ---------- SMALL UTILS ---------- */
function showNotification(message) {
  const notification = document.getElementById('notification');
  if (!notification) return;
  notification.textContent = message;
  notification.style.display = 'block';
  const exportBtn = document.getElementById('btnExportExcel');
  if (exportBtn) exportBtn.disabled = false;
  setTimeout(() => { notification.style.display = 'none'; }, 3000);
}
function cleanText(text) {
  return String(text || '')
    .replace(/State\s+of\s+South\s+Dakota\s+Department\s+of\s+Health/gi, '')
    .replace(/600\s+E\s+Capitol\s+Ave/gi, '')
    .replace(/Pierre,\s+SD\s+57501/gi, '')
    .trim();
}
function styledCell(value) {
  return `<td style="color: ${value ? 'black' : 'white'}">${value ?? ''}</td>`;
}
function isDate(str) {
  return /^\d{2}\/\d{2}\/\d{4}$/.test(String(str || '').trim());
}
function currencyToNumber(v){
  const s = String(v ?? '').replace(/[,$]/g,'').trim();
  const num = parseFloat(s);
  return isNaN(num) ? 0 : num;
}
function formatMoney(n){
  return Number(n||0).toLocaleString('en-US',{style:'currency',currency:'USD'});
}

/* =========================================================
   PART A — PDF → SHEETS (from your first file)
========================================================= */
async function handleFile(event) {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
        const arrayBuffer = await file.arrayBuffer();
        const pdfData = new Uint8Array(arrayBuffer);

        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;

        // reset
        sheets = [];
        clientInfo = [];

        let currentSheetData = [];

        for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();

            let line = '';
            let lastY = null;

            textContent.items.forEach(item => {
                if (lastY !== null && Math.abs(item.transform[5] - lastY) > 10) {
                    line = cleanText(line);

                    if (line.includes("Disclaimer: Charges/Adjustments made after statement date")) {
                        if (currentSheetData.length > 0) {
                            processExtractedSheet(currentSheetData);
                            currentSheetData = [];
                        }
                    } else {
                        currentSheetData.push([line.trim()]);
                    }

                    line = '';
                }

                line += item.str + ' ';
                lastY = item.transform[5];
            });

            // capture dangling line
            if (line.trim()) {
                line = cleanText(line);
                if (line.includes("Disclaimer: Charges/Adjustments made after statement date")) {
                    if (currentSheetData.length > 0) {
                        processExtractedSheet(currentSheetData);
                        currentSheetData = [];
                    }
                } else {
                    currentSheetData.push([line.trim()]);
                }
            }
        }

        // Finalize last sheet
        if (currentSheetData.length > 0) {
            processExtractedSheet(currentSheetData);
        }

        if (sheets.length > 0) {
            showNotification('PDF data extracted successfully!');
            // Build the unified client objects and render preview
            buildAllClientsFromSheets();
            // show first client in preview
            if (allClients.length) renderFromClientObject(allClients[0]);
        } else {
            alert('No readable text extracted.');
        }
    } catch (error) {
        console.error('Error extracting PDF data:', error);
        alert('Failed to extract data. Check the console for details.');
    }
}
function processExtractedSheet(rawLines) {
    const flattened = rawLines.map(r => r[0]?.trim()).filter(Boolean);
    const name = extractClientName(flattened);
    const address = extractClientAddress(flattened);
    clientInfo.push({ name, address });

    const headerIndex = flattened.findIndex(line =>
        line.toLowerCase().includes("claim number")
    );

    const rawTop = flattened.slice(0, headerIndex).map(line => [line]);

    const tableRows = extractTableRows(flattened, headerIndex);
    const structured = buildStructuredTable(tableRows);

    const wsData = [
        ...rawTop,
        [],
        ...structured
    ];

    sheets.push(wsData);
}
function extractClientName(lines) {
    const nameLine = lines.find(line => line.includes("Client Name(s):"));
    if (!nameLine) return "[CLIENT NAME]";

    let name = nameLine.split("Client Name(s):")[1].trim().split(" (")[0];

    if (name.includes(",")) {
        const [last, first] = name.split(",");
        name = `${first.trim()} ${last.trim()}`;
    }

    return name;
}
function extractClientAddress(lines) {
    const index = lines.findIndex(line => line.includes(","));
    if (index === -1) return ["[ADDRESS LINE 1]", "[CITY, STATE ZIP]"];

    const raw = lines.slice(index + 1, index + 4)
        .map(line => line.trim())
        .filter(line => line.length > 0);

    return [
        raw[0] || "[ADDRESS LINE 1]",
        raw.find(line => /\d{5}/.test(line)) || "[CITY, STATE ZIP]"
    ];
}
function extractTableRows(lines, headerIndex) {
    if (headerIndex === -1) return [];

    return lines
        .slice(headerIndex + 1)
        .filter(line =>
            line.includes("CL-") || line.includes("Service Line#")
        );
}
function buildStructuredTable(rows) {
    const headers = [
        "Claim Number", "Service Date", "Procedure (and Codes)", "Units", "Unit Rate",
        "Total Charge", "Patient Charge", "Total Paid", "Insurance Paid", "Patient Paid",
        "Total Adjustment", "Total Balance", "Insurance Balance", "Balance Owed"
    ];

    const body = [];

    rows.forEach((line) => {
        const parts = line.trim().split(/\s+/);
        const dateIndex = parts.findIndex(part => /^\d{1,2}\/\d{1,2}\/\d{4}$/.test(part));
        if (dateIndex === -1) return;

        const claimOrServiceLine = parts.slice(0, dateIndex).join(' ');
        const serviceDate = parts[dateIndex];

        // Find first numeric value after the date (typically units)
        let unitsIndex = dateIndex + 1;
        while (unitsIndex < parts.length && isNaN(parts[unitsIndex]?.replace?.(/[$,]/g, ''))) {
            unitsIndex++;
        }

        const procedure = parts.slice(dateIndex + 1, unitsIndex).join(' ');
        const units = parts[unitsIndex] || '';
        const unitRate = parts[unitsIndex + 1] || '';
        const totalCharge = parts[unitsIndex + 2] || '';
        const patientCharge = parts[unitsIndex + 3] || '';
        const totalPaid = parts[unitsIndex + 4] || '';
        const insurancePaid = parts[unitsIndex + 5] || '';
        const patientPaid = parts[unitsIndex + 6] || '';
        const adjustment = parts[unitsIndex + 7] || '';
        const totalBalance = parts[unitsIndex + 8] || '';
        const insuranceBalance = parts[unitsIndex + 9] || '';
        const balanceOwedRow = parts[unitsIndex + 10] || '';

        body.push([
            claimOrServiceLine,
            serviceDate,
            procedure,
            units,
            unitRate,
            totalCharge,
            patientCharge,
            totalPaid,
            insurancePaid,
            patientPaid,
            adjustment,
            totalBalance,
            insuranceBalance,
            balanceOwedRow
        ]);
    });

    return [headers, ...body];
}
function exportToExcel() {
    if (sheets.length === 0) {
        alert("No sheets were generated from the PDF. Please check the file and try again.");
        return;
    }

    const wb = XLSX.utils.book_new();

    sheets.forEach((sheetData, index) => {
        const ws = XLSX.utils.aoa_to_sheet(sheetData);

        ws['!cols'] = [
            { wch: 20 }, { wch: 15 }, { wch: 40 }, { wch: 8 }, { wch: 12 },
            { wch: 14 }, { wch: 14 }, { wch: 12 }, { wch: 14 }, { wch: 12 },
            { wch: 16 }, { wch: 14 }, { wch: 18 }, { wch: 14 }
        ];

        XLSX.utils.book_append_sheet(wb, ws, `Invoice ${index + 1}`);
    });

    XLSX.writeFile(wb, "Invoice_Statement.xlsx");
}

/* =========================================================
   PART B — EXCEL → PREVIEW/WORD (from your second file)
   (unchanged public API: processFile(), downloadWord(), extractData())
========================================================= */
function processFile() {
  const file = document.getElementById('fileUpload')?.files?.[0];
  if (!file) {
    alert("Please select a file first.");
    return;
  }

  const reader = new FileReader();
  reader.onload = (e) => {
    const data = new Uint8Array(e.target.result);
    const workbook = XLSX.read(data, { type: 'array' });

    // reset
    allClients = [];

    // Build clients from workbook (re-using the same shape as PDF path)
    buildAllClientsFromWorkbook(workbook);

    // Display first client
    if (allClients.length) {
      const first = allClients[0];
      clientName = first.clientName;
      formattedAddressLines = first.addressLines;
      sortedData = first.tableRows;
      balanceOwed = first.balanceOwed;

      const cn = document.getElementById('clientName');
      if (cn) cn.innerText = clientName;

      const ca = document.getElementById('clientAddress');
      if (ca) {
        ca.innerHTML = `<p>${formattedAddressLines[0] ?? ''}</p><p>${formattedAddressLines[1] ?? ''}</p>`;
      }

      extractData(sortedData);
    }
  };

  reader.readAsArrayBuffer(file);
}

function extractData(rows) {
  const tableBody = document.querySelector('#dataTable tbody');
  if (!tableBody) return;
  tableBody.innerHTML = '';
  balanceOwed = 0;

  rows.forEach((row) => {
    const {
      claimOrServiceLine,
      serviceDate,
      procedure,
      units,
      unitRate,
      totalCharge,
      patientCharge,
      totalPaid,
      insurancePaid,
      patientPaid,
      adjustment,
      totalBalance,
      insuranceBalance,
      balanceOwedRow
    } = row;

    const tr = document.createElement('tr');
    tr.innerHTML =
      styledCell(claimOrServiceLine) +
      styledCell(serviceDate) +
      styledCell(procedure) +
      styledCell(units) +
      styledCell(unitRate) +
      styledCell(totalCharge) +
      styledCell(patientCharge) +
      styledCell(totalPaid) +
      styledCell(insurancePaid) +
      styledCell(patientPaid) +
      styledCell(adjustment) +
      styledCell(totalBalance) +
      styledCell(insuranceBalance) +
      styledCell(balanceOwedRow);
    tableBody.appendChild(tr);

    balanceOwed += currencyToNumber(balanceOwedRow);
  });
}

async function downloadWord() {
  if (!allClients.length) {
    alert('No data to export.');
    return;
  }

  const {
    Document, Packer, Paragraph, Table, TableRow, TableCell,
    WidthType, TextRun, AlignmentType, BorderStyle, PageOrientation
  } = docx;

  const currentDate = new Date().toLocaleDateString('en-US', {
    year: 'numeric', month: '2-digit', day: '2-digit'
  });

  const sections = allClients.map((client, index) => {
    const {
      clientName,
      addressLines,
      tableRows,
      balanceOwed
    } = client;

    // Filter out any tableRows that contain the disclaimer text.
    const validRows = tableRows.filter(row =>
      !row.claimOrServiceLine?.includes("Disclaimer: Charges/Adjustments made after statement date will appear on your next statement")
    );

    // Header row
    const headerRow = new TableRow({
      children: [
        "Claim Number", "Service Date", "Procedure (and Codes)", "Units", "Unit Rate", "Total Charge",
        "Patient Charge", "Total Paid", "Insurance Paid", "Patient Paid", "Total Adjustment",
        "Total Balance", "Insurance Balance", "Balance Owed"
      ].map(text =>
        new TableCell({
          children: [new Paragraph({ children: [new TextRun({ text, bold: true })] })],
          shading: { fill: "D3D3D3" }
        })
      )
    });

    // Body rows built from validRows only
    const bodyRows = validRows.map((row, idx) => {
      const isClaimRow = row.claimOrServiceLine?.includes("CL-");
      const nextRow = validRows[idx + 1];
      const nextIsServiceLine = nextRow && nextRow.claimOrServiceLine?.includes("Service Line#");
      const whiteOut = isClaimRow && nextIsServiceLine;

      const blackText = (text) => new TextRun({ text: text ?? '', size: 22, color: '000000' });
      const whiteText = (text) => new TextRun({ text: text ?? '', size: 22, color: 'FFFFFF' });

      return new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ children: [blackText(row.claimOrServiceLine)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.serviceDate)] })] }),
          new TableCell({ children: [new Paragraph({ children: [whiteOut ? whiteText(row.procedure) : blackText(row.procedure)] })] }),
          new TableCell({ children: [new Paragraph({ children: [whiteOut ? whiteText(row.units) : blackText(row.units)] })] }),
          new TableCell({ children: [new Paragraph({ children: [whiteOut ? whiteText(row.unitRate) : blackText(row.unitRate)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.totalCharge)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.patientCharge)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.totalPaid)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.insurancePaid)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.patientPaid)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.adjustment)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.totalBalance)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.insuranceBalance)] })] }),
          new TableCell({ children: [new Paragraph({ children: [blackText(row.balanceOwedRow)] })] }),
        ]
      });
    });

    // Total row
    const totalRow = new TableRow({
      children: [
        new TableCell({
          children: [new Paragraph({ text: "Total", bold: true })],
          columnSpan: 13,
          shading: { fill: "D3D3D3" }
        }),
        new TableCell({
          children: [new Paragraph({ text: formatMoney(balanceOwed), bold: true })],
          shading: { fill: "D3D3D3" }
        })
      ]
    });

    // PAY THIS AMOUNT table box
    const payAmountBox = new Table({
      alignment: AlignmentType.RIGHT,
      width: { size: 50, type: WidthType.PERCENTAGE },
      rows: [
        new TableRow({
          children: [
            new TableCell({
              children: [
                new Paragraph({
                  alignment: AlignmentType.CENTER,
                  indent: { left: 750 },
                  children: [
                    new TextRun({
                      text: `PAY THIS AMOUNT: ${formatMoney(balanceOwed)}`,
                      alignment: AlignmentType.CENTER,
                      bold: true,
                      size: 28
                    })
                  ]
                })
              ],
              borders: {
                top: { style: BorderStyle.SINGLE, size: 4 },
                bottom: { style: BorderStyle.SINGLE, size: 4 },
                left: { style: BorderStyle.SINGLE, size: 4 },
                right: { style: BorderStyle.SINGLE, size: 4 }
              }
            })
          ]
        })
      ]
    });

    return {
      properties: {
        page: {
          size: { width: 12240, height: 15840, orientation: PageOrientation.PORTRAIT },
          margin: { top: 360, bottom: 360, left: 360, right: 360 }
        }
      },
      children: [
        new Paragraph({
          alignment: AlignmentType.RIGHT,
          children: [new TextRun({ text: `Statement Date: ${currentDate}`, bold: true, size: 24 })],
          spacing: { after: 200 },
          indent: { left: 750 }
        }),
        payAmountBox,
        new Paragraph({ spacing: { after: 200 }, alignment: AlignmentType.CENTER, indent: { left: 750 } }),
        new Paragraph({ text: "", spacing: { after: 800 } }),
        // Client Info
        new Paragraph({
          children: [new TextRun({ text: clientName, bold: true, size: 24 })],
          indent: { left: 1440 },
          spacing: { after: 150 }
        }),
        ...addressLines.map(line =>
          new Paragraph({
            children: [new TextRun({ text: line, size: 24, bold: true })],
            indent: { left: 1440 },
            spacing: { after: 150 }
          })
        ),
        new Paragraph({ spacing: { after: 750 } }),
        new Table({
          width: { size: 100, type: WidthType.PERCENTAGE },
          rows: [headerRow, ...bodyRows, totalRow]
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: "Disclaimer: The Adjustment column shows total reductions applied to your charges. These include write-offs and adjustments from your insurance provider, as well as any discounts you received through our South Dakota sliding fee scale program. These amounts are not owed and have already been deducted from your balance.",
              italics: true
            })
          ],
          spacing: { before: 200 }
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: "For any questions, concerns, or to make a payment over the phone, please call Family Health Education Services at (605) 717-8920. Our billing team is available Monday - Thursday, 8:00 AM to 5:00 PM. We offer payment plans in any amount and are happy to work with you on a schedule that fits your needs. Please note that accounts with no payment activity or effort to resolve the balance within 90 days of the billing date may be subject to collections.",
              bold: true
            })
          ],
          spacing: { before: 200 }
        }),
        ...(index < allClients.length - 1 ? [new Paragraph({ children: [], pageBreakBefore: true })] : [])
      ]
    };
  });

  const doc = new Document({ sections });

  try {
    const blob = await Packer.toBlob(doc);
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `Invoices_${currentDate.replaceAll('/', '-')}.docx`;
    link.click();
    URL.revokeObjectURL(link.href);
  } catch (err) {
    console.error("❌ Error generating Word doc:", err);
  }
}

/* =========================================================
   BRIDGE HELPERS — unify both paths for preview/Word
========================================================= */
// Build canonical client objects from AoA `sheets` (PDF path)
function buildAllClientsFromSheets() {
  allClients = sheets.map((aoa, idx) => {
    const headerIndex = aoa.findIndex(r =>
      String(r?.[0] || '').toLowerCase().includes('claim number')
    );
    const header = aoa[headerIndex] || [
      "Claim Number","Service Date","Procedure (and Codes)","Units","Unit Rate",
      "Total Charge","Patient Charge","Total Paid","Insurance Paid","Patient Paid",
      "Total Adjustment","Total Balance","Insurance Balance","Balance Owed"
    ];
    const rows = aoa.slice(headerIndex + 1).filter(r => r && r.length && r[0]);

    const objects = rows.map(r => ({
      claimOrServiceLine: r[0], serviceDate: r[1], procedure: r[2], units: r[3], unitRate: r[4],
      totalCharge: r[5], patientCharge: r[6], totalPaid: r[7], insurancePaid: r[8], patientPaid: r[9],
      adjustment: r[10], totalBalance: r[11], insuranceBalance: r[12], balanceOwedRow: r[13]
    }));

    const totalBalance = rows.reduce((acc, r) => acc + currencyToNumber(r[13]), 0);

    const info = clientInfo[idx] || { name: `[CLIENT ${idx + 1}]`, address: ["[ADDRESS LINE 1]", "[CITY, STATE ZIP]"] };

    return {
      clientName: info.name,
      addressLines: info.address,
      tableRows: objects,
      header,
      balanceOwed: totalBalance
    };
  });
}

// Build canonical client objects from a loaded workbook (Excel path)
function buildAllClientsFromWorkbook(workbook) {
  allClients = [];
  workbook.SheetNames.forEach((sheetName) => {
    const sheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

    const headerIndex = jsonData.findIndex(row => String(row?.[0] || '').toLowerCase().includes('claim number'));
    const topLines = jsonData.slice(0, headerIndex).map(r => r[0]);

    const nameLine = topLines.find(line => String(line || '').includes("Client Name(s):")) || "";
    let name = nameLine.split("Client Name(s):")[1]?.split(" (")[0]?.trim() || "[CLIENT NAME]";
    if (name.includes(",")) {
      const [last, first] = name.split(",");
      name = `${first.trim()} ${last.trim()}`;
    }
    const addressLines = [
      jsonData[10]?.[0]?.trim() || "[ADDRESS LINE 1]",
      jsonData[11]?.[0]?.trim() || "[CITY, STATE ZIP]"
    ];

    const tableRows = jsonData.slice(headerIndex + 1).filter(r => r[0]);
    const cleanedRows = tableRows.map(r => ({
      claimOrServiceLine: r[0], serviceDate: r[1], procedure: r[2], units: r[3], unitRate: r[4],
      totalCharge: r[5], patientCharge: r[6], totalPaid: r[7], insurancePaid: r[8], patientPaid: r[9],
      adjustment: r[10], totalBalance: r[11], insuranceBalance: r[12], balanceOwedRow: r[13]
    }));

    const totalOwed = tableRows.reduce((acc, r) => acc + currencyToNumber(r[13]), 0);

    allClients.push({
      clientName: name,
      addressLines,
      tableRows: cleanedRows,
      header: [
        "Claim Number", "Service Date", "Procedure (and Codes)", "Units", "Unit Rate",
        "Total Charge", "Patient Charge", "Total Paid", "Insurance Paid", "Patient Paid",
        "Total Adjustment", "Total Balance", "Insurance Balance", "Balance Owed"
      ],
      balanceOwed: totalOwed
    });
  });
}

// Render preview from a canonical client object (used by PDF path)
function renderFromClientObject(client){
  if (!client) return;

  // update globals to keep your other functions happy
  clientName = client.clientName;
  formattedAddressLines = client.addressLines;
  sortedData = client.tableRows;
  balanceOwed = client.balanceOwed;

  // header
  const cn = document.getElementById('clientName');
  if (cn) cn.innerText = clientName;

  const ca = document.getElementById('clientAddress');
  if (ca) ca.innerHTML = `<p>${formattedAddressLines[0] ?? ''}</p><p>${formattedAddressLines[1] ?? ''}</p>`;

  // table
  extractData(sortedData);
}

/* =========================================================
   EVENT WIRING — non-destructive (bind if elements exist)
========================================================= */
(function wireUp() {
  const pdfInput = document.getElementById('fileInput');
  if (pdfInput && !pdfInput._wired) {
    pdfInput.addEventListener('change', handleFile);
    pdfInput._wired = true;
  }
  const exportBtn = document.getElementById('btnExportExcel');
  if (exportBtn && !exportBtn._wired) {
    exportBtn.addEventListener('click', exportToExcel);
    exportBtn._wired = true;
  }
  // Excel flow keeps using your original "Process File" button that calls processFile()
})();

</script>
</body>
</html>
